# 13.2 스레드 안전성

**`스레드 안전성?`**

Java Concurrency In Practice 의 저자 브라이언 게츠가 내린 정의. <br> 
여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 충족하며 객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면 "그 객체는 스레드 안전하다" 라고 말한다.
- 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요가 없다.
- 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.


여러 스레드가 이용할 수 있는 공통 기능을 제공하려면 코드가 스레드 안전해야 한다. <br>
동기화 등의 안전장치를 코드 자체에 완벽하게 내장해서, 호출자는 멀티스레드 환경인지 특별히 고려하지 않고 그냥 사용해도 안전하게 사용할 수 있어야 한다는 뜻이다. 

## 13.2.1 자바 언어의 스레드 안전성

스레드 안전성은 여러 스레드가 공유하는 데이터에 대한 것이다. <br> 단일 스레드 환경이나 다른 스레드와 아무런 데이터도 공유하지 않는다면, 동시 실행이든 순차 실행이든 스레드 안전성 관점에선 어떤 차이도 없다. 

스레드 안전성은 '안전함의 정도'에 따라 여러 단계로 분류할 수 있다.<br>
자바 언어에선 공유 데이터의 안전함 정도를 다음 다섯 단계로 나눈다.
- 불변
- 절대적 스레드 안전
- 조건부 스레드 안전
- 스레드 호환
- 스레드 적대적

___

### 불변

- 불변이란 '변하지 않는다'를 의미한다.
- 자바 메모리 모델이 개정된 Jdk 5 이후에선 불변 객체는 객체 내 메서드 구현과 호출자에서 아무런 장치 없이도 스레드 안전하다.
- 불변 객체가 올바르게 만들어진다면 외부에 보이는 상태는 절대 달라지지 않으므로 일관성이 깨질 일이 없다.
- 따라서 '불변성' 은 가장 완전무결하다.

**객체의 메서드가 자신의 상태에 영향을 주지 않는 방법**
- 상태에 해당하는 모든 변수를 final 선언하기
    - 기본 데이터 타입은 final 선언하면 불변성이 보장된다. 
    - 실제로 java.lang.Integer 클래스 내부에서도 int 변수를 final 선언하였다.
    - 하지만, 객체라면 상태가 수정되지 않도록 해야 한다. (주의)
    - java.lang.String 은 불변이다. 내부 메서드에선 원래 값은 그대로 둔 채 새로 생성한 인스턴스를 반환한다.
- 자바가 제공하는 불변 타입 사용
    - 열거 타입
    - Long, Double, BigDecimal 등 java.lang.Number의 하위 클래스
    - 단, Number 의 하위 클래스 중 AtomicInteger 와 AtomicLong 은 불변이 아니다.
        - 내부적으로 락 없이 CAS(Compare-And-Swap) 기법으로 동기화 없이 스레드 안전하게 값을 읽고 쓸 수 있도록 만들어진 가변 객체이다.
        - 따라서 호출자는 동기화 신경쓰지 않고 값을 변경할 수 있다. 

___

### 절대적 스레드 안전 
- 브라이언 게츠가 정의했던 '스레드 안전성' 정의를 완벽히 충족한다. (넓은 의미의 스레드 안전과 구분을 위해 '절대적' 을 붙였다.)
- '호출자가 추가적인 동기화를 하지 않아도 된다' 를 충족시키기 위해선 꽤 비용이 많이 들거나 비현실적일 수 있다.
- 그래서 자바 API에서 스레드 안전하다고 표시된 대부분이 절대적 스레드 안전임을 나타내진 않는다.
    - java.util.Vector 의 add(), get() 등 모든 메서드는 synchronized 로 되어 있다.
    - 이는 효율적이진 못해도 원자성, 가지성, 실행 순서를 보장한다. 
    - 하지만 synchronized 가 붙어 있어도 호출자가 추가로 동기화할 필요가 없다는 것을 의미하진 않는다.

Vector 의 스레드 안전성 테스트
```java
public class VectorTest_1 {
    private static Vector<Integer> vector = new Vector<Integer>();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 10; i++) {
                vector.add(i);
            }

            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) {
                        vector.remove(i); // vector 에서 요소 삭제
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) { 
                        System.out.println(vector.get(i));     
                    }
                }
            });

            removeThread.start();
            printThread.start();

            // 스레드를 너무 많이 만들지 말자. 운영 체제가 느려질 수 있다.
            while (Thread.activeCount() > 20);
        }
    }
}
```
- Vector 클래스의 모든 메서드는 synchronized 키워드가 붙어 있다고 했다.
- 이때 실행 결과는 remove() 호출에서 ArrayIndexOfBoundsException 이 터질 수 있다.
- 따라서 멀티스레드 환경에서 호출자가 추가적인 동기화 조치 없이 사용하면 여전히 안전하지 않다는 것이다.
- 안전하지 않다, 왜?
    - vector.size() 로 벡터의 크기를 얻은 후
    - 다른 스레드가 벡터에서 원소를 제거한다면? 잘못된 인덱스로 접근할 수 있다.

아래와 같이 synchronized 동기화를 해주면 올바르게 실행된다.
```java
Thread removeThread = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized(vector){ // 동기화 블록으로 감싸기
            for (int i = 0; i < vector.size(); i++) {
                vector.remove(i); // vector 에서 요소 삭제
            }
        }
    }
});

Thread printThread = new Thread(new Runnable() {
    @Override
    public void run() {
        synchronized(vector){
            for (int i = 0; i < vector.size(); i++){ 
                System.out.println(vector.get(i));     
            }
        }
    }
});
```

vector 가 절대적 스레드 안전하기 위해선 vector 내에서 일관된 스냅숏을 유지해야 한다. 즉, 상태가 변하지 않아야 한다. 하지만 벡터의 원소가 변경될 때마다 새로운 스냅숏을 찍어낸다면 메모리와 성능 면에서 큰 비용이 있을 것이다.

___

### 조건부 스레드 안전
- 우리가 일반적으로 스레드 안전하다라고 말할 때의 안전 수준을 의미한다.
- 단일한 작업(메서드)은 별도 보호 조치 없이 스레드로부터 안전하게 실행될 수 있다.
    - 즉, 각각 메서드만 보면 안전하다.
- 하지만, 특성 순서로 여러 메서드가 조합된 경우엔 호출자에서 동기화가 필요하다.
- ex. Vector 와 HashTable, Collections 클래스의 synchronized Collection() 메서드로 래핑한 컬렉션 

____

### 스레드 호환
- 객체 자체는 스레드로부터 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 한경에서도 안전하게 사용 가능하다.
- 이런 클래스는 일반적으로 스레드 안전하지 않다고 말한다.
- 자바의 클래스 대다수가 이 분류에 속한다.
- ArrayList 와 HashMap 등의 컬렉션 클래스
    - 앞선 Vector 와 HashTable 의 스레드 호환 버전이다.

___

### 스레드 적대적
- 호출자가 동기화 조치를 하여도 멀티스레드 환경에서 안전하게 사용할 수 없는 수준이다.
- 자바 언어는 처음부터 스레드를 지원하였으므로 스레드 적대적 코드는 드물다.
- 스레드 적대적 코드는 해로우므로 피해야 한다.
- ex. Thread.suspend(), Thread.resume(), System.setIn(), System.setOut(), System.runFinalizerOnExit()
    - 동기화 조치를 하였을 때 suspend() 호출 시 락을 해제하지 않고 스레드를 멈추므로 resume() 으로 재개하려고 해도 락을 얻지 못해 데드락(deadlock)에 빠질 수 있다.

## 13.2.2 스레드 안전성 구현
스레드 안전성을 구현하는 코드 작성법과 가상 머신이 제공하는 동기화와 락 메커니즘을 알아본다.<br>
jvm 이 스레드 안전성에 대처하는 원리와 동작 과정을 이해하면 개발자는 더 올바른 작성법을 쉽게 생각해낼 수 있다.

___

### 상호 배제(mutual exclusion) 동기화
- 상호 배제 동기화에서 '상호 배제'는 수단이고 '동기화'는 목적이다.
- 상호 배제는 가장 일반적이면서 가장 중요한 동시성 보장 수단이다.
- 여러 스레드가 접근하려는 상황에서 단 하나의 스레드(세마포어는 n개)만 데이터를 사용하도록 보장한다.
- 대표적인 상호 배제 동기화 구현
    - 뮤텍스
    - 세마포어
- 자바에서의 가장 기본적인 수단은 코드 블록을 동기화하는 **`synchronized`** 키워드다.
- 또는 java.util.concurrent 패키지 (Concurrency utilities)


**`monitorenter, monitorexit`**
- javac가 synchronized 키워드를 컴파일하면 monitorenter 와 monitorexit 라는 두 바이트코드 명령어가 생성된다.
- 두 명령어 모두 락으로 사용되는 객체를 참조 타입 매개 변수로 받아 블록 전후에 각각 실행된다.
    - synchronized 키워드에 객체를 명시하면 해당 객체가 매개변수로 넘겨진다.
    - 객체를 명시하지 않으면 메서드의 위치에 따라 적절한 객체가 선택된다.
    - 인스턴스 메서드면 해당 인스턴스(this), 정적(static) 메서드면 인스턴스 없이 호출되므로 대신 해당 클래스의 객체(MyClass.class)가 전달된다. 
- **락을 얻고 해제하는 과정**
    - moritorenter 명령어를 실행하면서 먼저 객체의 락을 얻으려 시도한다.
    - 객체가 락이 걸려 있지 않거나 현재 스레드가 락을 이미 소유하고 있다면(재진입) 락 카운터 값을 1씩 증가시킨다.
    - monitorexit 명령어를 실행할 땐 1씩 감소시킨다.
    - 카운터가 0이 되면 그 객체의 락이 해제된다.
    - 락을 얻지 못한 스레드는 현재 락을 소유한 스레드가 락을 해제할 때까지 블록된다.
- 자바 가상 머신 명세에서 설명하는 두 결론
    - 이미 락을 소유한 스레드는 동기화 블록에 여러 번 재진입이 가능하다.
    - synchronized 로 동기화된 블록은 락을 소유한 스레드가 일을 끝내고 락을 해제할 때까지 다른 스레드의 진입을 무조건 차단한다. 즉, 중간에 락을 얻을 방법이 전혀 없다.


**`synchrozied 의 한계`**

synchronized 키워드는 매우 주의해서 사용해야 한다.
- 락을 소유하는 방식은 실행 비용 측면에서 매우 무거운 작업이다. 
    - 주류 jvm 에선 플랫폼 스레드를 커널 스레드가 매핑해서 사용한다고 하였다. 따라서 플랫폼 스레드를 정지하거나 깨우는 것은 커널 스레드의 도움을 받아야 하며 이것은 사용자 모드와 커널 모드 전환을 피할 수 없는 일이다. 
    - 이 os 모드 전환에서 프로세서의 시간을 많이 소모하게 된다. 
    - 특히, getter/setter 와 같은 간단한 작업에 synchronized 동기화를 걸었다면 실제 코드 실행 자체보다 모드 전환에 더 긴 시간이 소요될 수 있다. 따라서 꼭 필요한 경우에만 제한적으로 사용해야 한다.
- 나름 Jvm 에서 최적화는 이루어진다.
    - 스레드를 블록하라고 os 에 알리기 전에 바쁜 대기(busy waiting/spinning) 코드를 추가하여 모드 전환이 자주 일어나는 것을 막는다.
    - 따라서 만약 짧은 시간 안에 락을 얻을 수 있는 경우 os 호출을 막을 수 있다


**`java.util.concurrent.Lock`**
- 또 다른 상호 배제 동기화 수단이다.
- 동시성 라이브러리의 Lock 인터페이스를 사용하여 논블록 구조의 상호 배제 동기호를 구현할 수 있다.
- 언어 특성에 얽매이지 않고 클래스 라이브러리 수준에서 동기화를 구현하였다.
    - 따라서 다른 스케줄링 알고리즘, 특성, 성능, 의미를 갖는 다양한 락으로 확장할 수 있게 되었다. 
- ReentrantLock이 Lock 인터페이스를 구현한 대표적인 예다.
    - 또 다른 대표적 예로는 ReentrantReadWriteLock 도 있다. (이름은 비슷하지만 상속 관계는 아니다..)

**ReentrantLock 란?**
- synchronized 와 같이 재진입이 가능한 락이다. 
- 코드는 다르나 기본적인 사용법은 synchronized 와 비슷하다. 하지만 몇가지 기능을 더 제공한다.
- 대기 중 인터럽트
    - 락을 소유한 스레드가 오랜 시간 해제하지 않을 때 대기 중인 스레드들은 락을 포기하고 다른 일을 할 수 있다.
    - 실행 시간이 매우 긴 동기화 작업에서 유용하다.
- 페어 락
    - 같은 락을 얻기 이해 대기하는 스레드가 많을 때 락 획득을 시도한 시간 순서대로 락을 얻는다.
    - 언페어 락은 락이 해제되면 대기하던 모든 스레드가 락을 얻을 수 있는 후보가 된다.
    - synchronized 는 언페어 락에 해당한다.
    - ReentrantLock 도 기본적으로는 언페어 락이지만 생성자에서 페어 락 여부를 정할 수 있다.
    - 하지만, 페어 락은 성능이 급격히 떨어져 처리량에 악영향을 줄 수 있어 주의해야 한다.
- 둘 이상의 조건 지정
    - ReentrantLock 은 동시에 여러 개의 Condition 객체와 연결 지을 수 있다.
    - synchronized 도 락 객체의 wait(), notify(), notifyAll() 메서드는 모두 특정 조건을 구현할 수 있다. wait 는 어떤 조건이 충족될 때까지 락을 놓고 대기하라, notify 는 wait 하는 스레드 중 하나를 깨워라. 하지만, 둘 이상 조건을 주고 싶다면 또 락을 추가해야 한다.
    - ReentrantLock 은 newCondition() 메서드를 여러 번 호출하기만 하면 된다.

이상의 기능이 필요하다면 ReentrantLock 을 사용하면 좋다. <br>
하지만, 성능이 중요하다면?
- jdk 5까지
    - synchronized 가 멀티코어 이상 시스템에서 성능이 급격히 떨어졌다.
    - ReentrantLock 는 상대적으로 안정적으로 유지되어 비교적 성능 우위에 있었다.
- jdk 6부터 synchronized 최적화
    - 두 방식의 성능이 거의 같다.
- 따라서, jdk 6 이상을 사용한다면 둘 방식 중 선택할 때 성능은 고려 대상이 아니다.


**`두 방식이 모두 가능하다면 synchronized 를 권장한다 `**
- 간결하고 쉽다.
    - synchronized 는 자바 구문 수준의 동기화 수준이므로 매우 간결하다.
    - 모든 개발자가 synchronized 엔 익숙하지만 Lock 은 낯설 이가 많다.
- Lock 은 finally 에서 명시적 해제해야 한다.
    - Lock 을 사용하여 unLock() 을 호출하지 않으면 당연히 락이 해제되지 않는다.
    - 즉, 락 해제를 개발자가 직접 호출하여 보장해야 한다.
    - synchronized 는 명시적 해제하지 않아도 되고, 예외가 발생했을 때 락 해제까지 Jvm 에서 보장한다.
- 길게 보면 동기화 최적화는 jvm 에 맡기는 게 유리하다.
    - synchronized 는 자바 언어 자체 제공이므로 jvm 에서 여러 내부 정보를 활용할 수 있다.
    - 클래스 라이브러리 차원의 Lock 을 이용하면 jvm 은 어느 스레드가 어느 락을 소유하는지 알기 어렵다.

___

### 논블로킹 동기화

- 상호 배제 동기화의 큰 문제는 블로킹으로 인한 스레드 일시 정지와 깨우기로 인한 성능 저하이다. (블로킹 동기화)
- 문제 해결 방법 관점에서 상호 배제 동기화는 '비관적 동시성 전략'에 속한다.
    - 락과 같은 동기화 장치가 없다면 반드시 문제가 생길 것이라고 가정한다. 비관적 락처럼..?
    - 따라서 실제 경합이 이루어지는지와는 상관없이 락을 건다.(그치만 실제론 jvm 에서 최적화하여 락의 상당수를 얿앤다.)
    - 이 경우 사용자모드에서 커널 모드로 전환되고, 락 카운터 계산하고, 블록된 스레드를 깨워야 하는지에 대한 작업이 뒤따른다.
- 반면, 충돌 감지를 기반으로 작동하는 '낙관적 동시성 전략' 
    - **잠재적으로 위험할 수 있더라도 일단 작업을 진행한다.**
    - 만약 공유 데이터를 놓고 경합하는 스레드가 없다면 가장 성공적인 경우이다.
    - 하지만, 충돌이 발생하면 보완 조치를 취한다.
        - 가장 흔한 조치는 경합하는 공유 데이터가 없을 때까지 재시도하는 것이다.
    - 스레드를 일시 정지할 일은 없다. 이 방식을 따르는 코딩을 `락 프리(lock-free)` 프로그래밍이라고 한다.
- '하드웨어 명령어(CPU 명령어) 집합의 발전'이 낙관적 동시성 전략이 가능하게 된 전제이다.
    - 왜? 작업 진행과 충돌 감지라는 두 단계를 마치 하나의 명령어처럼 원자적으로 처리해야 하기 때문이다.
    - 즉, 원래는 의미상 하나이나 여러 연산으로 처리되어야 하는 작업을 단 하나의 프로세서 명령어로 완료할 수 있게 된 것이다.
    - 따라서 하나의 명령어로 처리되므로 다른 스레드가 중간에 낄 일이 없다.

원자적으로 처리되는 하드웨어 명령어 대표 예시
- TAS(Test-and-Set): 검사와 지정
- FAA(Fetch-and-Add): 페치와 증가
- Swap(교환)
- CAS(Compare-and-Swap): 비교와 교환
- LL/SC(Load-Linked/Store-Conditional): 적재와 저장

**`CAS(Compare-and-Swap)`**
- 피연산자 3개 메모리 위치(V), 예상하는 이전 값(A), 새로 설정할 값(B)이 필요하다.
- CAS 명령어를 실행하는 CPU는 V의 값이 A와 같으면 B로 갱신하고, 같지 않으면 갱신하지 않는다.
- 그리고 V의 값의 갱신 여부와는 상관없이 A를 반환한다.
- 즉, 값을 읽고, 값을 비교하고, 값을 갱신하는 연산이 모두 하나의 명령어로 처리된다.
- jdk 5부턴 자바 클래스 라이브러리 내부에선 Unsafe 클래스를 통해 CAS 연산을 사용하기 시작했다.
    - `sun.misc.Unsafe` 클래스의 compareAndSwapInt() 등 메서드로 제공되었는데,
    - 핫스팟 jvm 이 이 메서드를 JIT 컴파일하여 메서드 호출을 없애고 프로세서에 맞는 CAS 명령어로 대체해주는 것이다.
- 하지만, Unsafe 는 사용자 프로그램에서 사용하도록 설계되진 않아서 개발자가 접근하는 API 는 아니다. 
    - 부트스트랩 클래스 로더(최상단 클래스 로더)가 로드한 즉, jdk 구현 내부에서만 Unsafe 사용이 가능하였다.
    - 따라서 jdk 8까진 오직 자바 클래스 라이브러리에서만 CAS 이용이 가능했다.
    - ex. java.util.concurrent.AtomicInteger 클래스는 Unsafe 의 CAS 연산을 이용하여 구현됨
    - 사용자 프로그램에선 리플렉션으로 접근 제한을 우회하거나 자바 클래스 라이브러리를 거쳐 간접 사용해야만 했다.
- jdk 9부턴 VarHandle 클래스를 통해 사용자 프로그램도 CAS 연산을 직접 이용할 수 있게 되었다.


AtomicInteger 클래스로 동기화한 예시
```java
public static AtomicInteger race = new AtomicInteger(0);

public static void increase(){
    race.incrementAndGet(); // CAS 를 통한 원자적 증가
}
```
- 스레드 20개를 만들어서 추가 조치 없이 단순 increase() 호출을 1만번씩 수행하면 올바르게 20만을 반환한다.
- synchronized 와 달리 락-프리이므로 성능 효율이 크게 개선된다.

[jdk 코드에서 가져온 AtomicInteger 클래스의 incrementAndGet()](https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/util/concurrent/atomic/AtomicInteger.java)

[Unsafe github 코드](https://github.com/AdoptOpenJDK/openjdk-jdk8u/blob/master/jdk/src/share/classes/sun/misc/Unsafe.java)
```java
/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

/**
 * Atomically adds the given value to the current value of a field
 * or array element within the given object <code>o</code>
 * at the given <code>offset</code>.
 *
 * @param o object/array to update the field/element in
 * @param offset field/element offset
 * @param delta the value to add
 * @return the previous value
 * @since 1.8
 */
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        // o 의 offset 값을 읽음
        // volatile 이므로 메인 메모리에서 최신 값을 읽어옴
        v = getIntVolatile(o, offset); 
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
```
- AtomicInteger 의 incrementAndGet()
    - 공유 변수를 CAS 연산을 통해 원자적 증가 연산 처리 후 증가된 값 반환
    - CAS 는 갱신 여부 상관 없이 이전 값을 반환하므로 증가된 값 반환을 위해 따로 +1 처리
    - 이때 +1 처리는 해당 스레드의 지역 변수 계산이므로 공유되는 것이 아니기 때문에 동시성 이슈가 일어나지 않음
- Unsafe 의 getAndAddInt()
    - volatile 로 계속 최신 값을 읽어옴
    - **while 문을 보면 새로운 값으로 갱신할 수 있을 때까지 CAS 를 끈임없이 재시도하고 있다.**

CAS 는 단순하고 효율적이다. 하지만 논리적 허점은 존재한다. 만약 V를 처음 읽었을 때 A고 할당할 준비가 되었을 때도 A였다면 다른 스레드가 값을 변경하지 않았다는 것인가? 답은 "모른다" 이다. A -> B -> A 였을 수 있기 때문이다. 이를 ABA 문제라고 한다. 하지만 ABA 문제는 동시성의 정확성에 영향은 없기 때문에 굳이..? 해결해야 하나..딱ㅎ..

___

### 동기화가 필요 없는 메커니즘
- 공유 데이터가 없다면 당연히 동기화도 할 필요가 없다.
- 태생부터 스레드 안전한 코드 두 가지 1. 재진입 코드, 2. 스레드 로컬 저장소
- 재진입 코드(순수 코드)
    - 순수 코드이다. 간단한 예시론 메서드 내 로직이 return x + y 인 경우
    - 내부 상태나 외부 상태나 어느것도 바꾸지 않으므로 그 자체로 안전하다.
    - 공통 특징은 전역 변수, 힙에 저장된 데이터, 공유 시스템 자원을 전혀 사용하지 않고, 
    - 필요한 정보는 매개변수로만 제공받는 것이다.
    - 재진입이 불가능한 코드를 호출하지도 않는다.
    - 재진입이 가능한지에 대한 판단 여부는 메서드의 반환값을 예측할 수 있고, 똑같은 입력엔 항상 같은 결과를 반환한다는 것이다. 
- 스레드 로컬 저장소 
    - 공유 데이터의 가시 범위를 각각 스레드로 제한하는 것이다.
    - 따라서 각자의 저장소를 가지는 것이므로 다른 스레드와 경합할 일이 사라지고 동기화가 필요 없다.
    - 자바에선 java.lang.ThreadLocal 로 스레드별 저장소를 만들 수 있다.
    - Thread 객체는 ThreadLocalMap 객체를 하나 가지며 키-값을 저장한다.
    - 키는 고유한 hashCode 값이며 값은 로컬 스레드 변수를 저장하여 키로 그 키에 대응하는 값을 넣고 뺄수 있다.


