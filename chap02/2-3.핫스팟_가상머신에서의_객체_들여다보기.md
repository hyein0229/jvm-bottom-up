# 2.3 핫스팟 가상머신에서의 객체 들여다보기

가장 보편적인 가상 머신 핫스팟 가상머신

핫스팟이 관리하는 자바 힙에서의 객체 생성, 레이아웃, 접근 방법 등 상세 내용을 알아보자

## 2.3.1 객체 생성

자바는 new 키워드를 이용해 객체를 생성한다. 

JVM 은 new 명령에 해당하는 바이트코드를 만난다면 해당 명령에 전달된 매개변수 (즉, 객체의 클래스인듯?) 가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인하고, 심벌 참조가 뜻하는 클래스가 로딩되어 초기화된 상태인지를 확인한다.

⇒ ***즉, new 의 대상인 클래스가 로딩되어 준비되어 있는 상태인지 확인하고, 아니면 로딩해야 한다.***

로딩이 완료된 클래스면 새 객체를 담을 메모리를 할당한다. 객체에 필요한 메모리 크기는 클래스 로딩 시점에 알 수 있다. 메모리 할당 방식은 **자바 힙이 규칙적이냐, 아니냐**에 따라 달라진다.

규칙적인가? → **GC 가 compact 를 하냐**에 따라 달린다.

1. 자바 힙이 규칙적인 경우 
    
    사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리한다.
    
    메모리 할당 시 여유 메모리의 시작 포인터를 여유 메모리 쪽으로 객체 크기만큼 이동시키는 ***포인터 밀치기 (bump the point-er)*** 방식을 사용한다.
    
    
2. 자바 힙이 불규칙적인 경우 
    
    사용 중인 메모리와 여유 메모리가 뒤섞여 있으므로 포인터 밀치기 방식 사용이 복잡해진다. 대신, 가용 메모리 블록을 목록으로 따로 관리하여 공간을 찾아 할당하는 **“여유 목록 (free list)”** 방식을 사용한다.
    

### 객체 생성의 문제점

1. 객체 생성은 매우 빈번함
2. 여유 메모리의 시작 포인터 위치를 수정하는 것도 스레드 안전하지 않으므로 동시성 문제 가능
    - 여러 스레드에서 동시에 메모리를 할당받으려 할 때

### 해결 방법

1. 메모리 할당을 동기화하는 방법
    - 비교 및 교환 (Compare-And-Swap, CAS) 및 실패 시 재시도 방식
    - 비교 → 현재 값이 기대한 값인가, 교환 → 기대한 값이어야 바꿈
    - 갱신을 원자적으로 수행하여 안전
2. 스레드마다 다른 독립적인 공간을 할당
    - 스레드 로컬 할당 버퍼 (TLAB) → 독립적이므로 동기화 작업 필요 X
    - TLAB 에서 할당 받다가 부족하면 그때 동기화를 하여 새로운 버퍼를 할당받음
    - 동기화 불필요하므로 성능 향상

    

### 메모리 할당 과정

- 메모리 초기화
    - 할당받은 공간을 0으로 초기화
    - TLAB 를 사용한다면 TLAB 할당 시 미리 초기화 수행
    - 모든 인스턴스 필드가 각 타입에 맞는 0 값을 담고 있다.
    - 객체의 인스턴스 필드를 초기화하지 않아도 사용할 수 있는 이유이다.
- 각 객체 정보 설정
    - 어느 클래스의 인스턴스인가, 클래스의 메타 정보는 어떻게 찾는가, 해시 코드 등
    - 객체의 객체 헤더에 저장됨
    - JVM 관점에선 새로운 객체가 거의 다 만들어진 상태지만, 개발자의 의도대로 생성자 호출을 통해 초기화해야 비로소 사용 가능한 진짜 객체가 완성됨
    - 현재 상태 : 생성자(init) 호출 전, 모든 필드가 기본값 0인 상태
- 생성자 호출
    - 개발자가 정의한 init 호출
    - 자바 프로그램 관점에서의 객체 생성 상태
- 진짜 사용 가능한 객체 완성



> 자바 컴파일러는 자바 언어의 new 키워드 발견 시 바이트 코드 명령어인 new 와 invokespecial 로 변환한다. new 명령어는 JVM 관점에서의 객체 생성인 “메모리 할당 단계” 를 수행하고 invokespecial 명령어는 자바 프로그램 관점에서의 객체 생성인 “생성자 호출 단계” 를 수행한다.
만약 자바 코드에서 new 연산자가 아닌 다른 방식으로 객체를 생성한다면 바이트코드에서  invokespecial 명령어가 연이어 나오지 않을 수 있다. 



### 핵심은?

- 자바에서 인스턴스 필드 초기화 없이 사용할 수 있는 이유는 JVM 에서 자동 0으로 초기화하기 때문
- TLAB 사용의 이점은?
    - 메모리가 미리 초기화되어 있으므로 객체 생성 속도 향상
    - TLAB 은 스레드 별로 독립된 메모리 버퍼이므로 동기화 작업이 없어 성능 향상
- 객체 생성 과정
    - 메모리 할당 → 메모리 초기화 → 객체 정보 설정 → 생성자 호출

## 2.3.2 객체의 메모리 레이아웃

핫스팟 가상머신은 객체를 ***세 부분***으로 나누어 힙에 저장한다.

- 객체 헤더
- 인스턴스 데이터
- 길이 맞추기용 정렬 패딩(alignment padding)

___

### 객체 헤더

- 객체 자체의 런타임 데이터 (마크 워드)
    - 해시 코드, GC 세대 나이, 락 정보 등
- 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터 (클래스 워드)
    - JVM 클래스 로딩 시 Metaspace 에 저장되는 클래스 정보를 참조하도록 함
    - 이를 통해 해당 객체가 어느 클래스의 인스턴스인지를 런타임에 알 수 있다.
    - 메모리 절약을 위해 클래스당 하나의 메타데이터만 생성하도록 하고 참조를 통한다.
- 배열의 경우엔 배열 길이를 저장 (배열 길이)
    - 객체 헤더에 저장되는 데이터는 배열에 담긴 ‘원소’ 타입이므로 배열 객체가 차지하는 메모리 크기를 얻기 위해선 길이 정보가 필요

JVM 은 객체 생성 시 객체 헤더의 메타데이터로부터 자바 객체의 크기를 얻는다.

___

### 인스턴스 데이터

- *객체가 실제로 담고 있는 정보*
- 프로그램 코드에서 정의한 다양한 타입의 필드 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 기록됨
- 정보 저장 순서는 JVM 할당 전략 매개 변수와 자바 소스 코드에서 필드를 정의한 순서에 따라 다르다.
- 핫스팟 가상 머신은 기본적으로 long/double, int, short/char, byte/boolean, 일반 객체 포인터 순으로 할당함

___

### 정렬 패딩

- 선택적으로 존재하며, 특별한 의미 없이 자리를 확보하는 역할만 한다.
- 목적은 객체의 시작 주소를 8바이트이 정수배로 맞추기 위함이다.
    - 이는 모든 객체의 크기가 8바이트의 정수배여야 한다는 뜻이다.
    - 따라서, 인스턴스 데이터가 조건을 충족하지 못하면 여분 공간을 사용하여 맞춘다.

## 2.3.3 객체에 접근하기

대다수 객체는 다른 객체 여러 개를 조합해 만들어진다. 자바 프로그램 스택에 있는 참조 데이터를 통해 힙에 있는 객체들에 접근하여 이를 조작한다.

객체에 접근하는 방식은 JVM 에 따라 구현 방식이 다른데, 주로 핸들 방식이나 다이렉트 포인터 방식을 사용하여 구현한다.

### 핸들 방식

- 스택의 참조가 핸들을 가리키고, 핸들이 실제 인스턴스를 가리킨다.
- 가장 큰 장점은?
    - 참조에 안정적인 핸들의 주소가 저장된다는 것
    - GC 과정에서 객체가 이동하는 일은 흔한데, 객체 위치가 바뀌어도 스택 참조에 손 댈 필요가 없다.
    - 즉, 핸들 내의 인스턴스 데이터 포인터만 변경하면 된다.
- 단점은 핸들을 통한 참조이므로 한 단계를 더 거친다는 것이다.

### 다이렉트 포인터 방식

- 스택의 참조가 실제 객체를 가리킨다.
- 가장 큰 장점은?
    - 핸들을 경유하지 않으므로 오버헤드가 없어 속도가 빠르다.
    - Java 에선 다른 객체에 접근할 일이 많으므로 이 오버헤드가 실행 시간에 영향을 줄 수 있기 때문
- 다만, 객체 이동 시에 참조 주소를 변경해주어야 한다.
- 핫스팟 JVM 에서 사용하는 방식

즉, 핸들 방식은 힙 내에서 객체 이동에 유리하지만 경유 단계가 있으므로 속도가 느리고, 다이렉트 포인터 방식은 바로 실제 객체로 접근이 가능하므로 속도가 빠르지만 객체 위치 이동 시 참조를 변경해주어야 한다.