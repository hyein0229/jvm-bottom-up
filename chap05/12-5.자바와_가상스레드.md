# 12.5 자바와 가상 스레드

- 자바는 운영 체제별 스레드 모델의 차이를 숨기는 통합된 스레드 인터페이스를 제공한다.
- 수많은 멀티스레드 애플리케이션과 프레임워크 탄생의 단초가 되었다.
- 예를 들어 자바 servlet을 사용하면 HTTP 요청 하나를 스레드 하나에 매핑하여 브라우저별로 1:1 서비스를 제공할 수 있다.
- 자바 언어와 프레임워크는 동시성 처리의 복잡성을 상당 부분 숨겨 준다는 이점이 있다.

## 12.5.1 커널 스레드의 한계

- 기존 자바 스레드 모델 → OS의 커널 스레드와 1:1 매핑되어 구현
- 오늘날 웹 애플리케이션 서비스 규모가 커지면서 동시 처리할 요청 처리량이 매우 급증함
- 따라서 현재 브라우저-서버 시스템은 서로 다른 시스템에 분산된 수많은 서비스가 협력해 외부 요청에 응답하는 일이 흔해졌다. 이러한 아키텍처를 마이크로서비스(MSA)라고 한다.
    - MSA는 서비스 각각의 복잡성은 줄이고 재사용을 높인다.
    - 또한 필연적으로 서비스 수를 늘리고 서비스별 응답 시간을 단축시킨다.
    - 또한 개별 서비스 공급자가 동시에 많은 요청을 처리할 수 있어야 서비스가 블록되지 않는다.
- 1:1 커널 스레드 모델은 MSA와 어울리지 않는다.
    - 자바 스레드 - 커널 스레드에 의존하므로 스레드 전환과 스케줄링 비용이 커진다.
    - 커널 자원을 사용하므로 시스템이 수용하는 스레드 수도 크게 제한된다.
    - 요즘 규모로는 요청당 실행 시간이 매우 짧아지고 수가 많아지면서 스레드 전환 비용이 매우 커진다.
    - 기존 자바 웹 서버의 스레드 풀 용량은 일반적으로 수십~200개 정도 였으므로 이러한 스레드 풀에 수백만 개의 요청이 쏟아지면 시스템이 처리는 가능할 수 있더라도 전환 손실이 상당하다.
- **즉, 한계점**
    - **기존 자바 스레드 모델은 OS의 커널 스레드를 사용하여 구현하므로 제한된 스레드 풀의 스레드 개수와 스레드 간 전환으로 인한 성능 손실이 많이 일어난다.**
    - 따라서 요즘의 애플리케이션의 서비스 규모가 커질수록 병목이 생기고 성능 저하를 일으킬 수 있다.

## 12.5.2 코루틴의 귀환

커널 스레드의 전환 비용이 높은 이유는 무엇일까

- 커널 스레드의 스케줄링 비용은 주로 사용자 모드와 커널 모드 사이의 전환 비용이다.
- 주로 인터럽트에 응답하고 현재 **실행 데이터를 저장하고 복원하는 비용**이 크다.
    - 문맥을 되돌리기 위해 레지스터와 캐시의 값, TLB 를 flush 하는 데 오버헤드가 발생한다.
    - 문맥이란 메서드 호출 과정에 쓰이는 다양한 지역 변수와 자원이다.
- 그러면 사용자 스레드를 사용하면 부하가 사라질까?
    - 아니다.
    - 하지만 문맥 저장과 복원 작업을 개발자가 가져온다면 시도할 수 있는 비용 절감 기법은 있다.
    - 대부분의 사용자 스레드는 협력적 스케줄링 형태로 설계되어 코루틴이라는 별칭으로 불린다.
- 코루틴의 장점
    - 커널 스레드보다 훨씬 가볍다.
    - 코루틴의 스택 크기는 JVM에서의 스레드 스택 크기에 비해 훨씬 작다.
    - 따라서 코루틴을 지원하는 애플리케이션은 코루틴이 수십만 개 공존할 수 있다.
- 코루틴의 단점
    - 호출 스택과 스케줄러 등 많은 것을 애플리케이션 수준에서 구현해야 한다.
    - 협력적 스케줄링 방식으로 작업을 처리해주어야 한다.
    

## 12.5.3 가상 스레드: 자바의 해법

기존 스레드 모델과 공존하며 프로그램에서 혼용할 수 있는 동시성 프로그래밍 모델을 제공한다. 

커널 스레드 - 플랫폼 스레드(기존 자바 스레드) - 가상 스레드로 이어진다.

**`기존 자바의 스레드 모델은?`**

- 자바 스레드 생성 시 JNI(Java native interface)를 통해 커널을 호출하고 OS의 커널 스레드를 생성하여 매핑 후 작업을 수행하는 형태이다.
- 커널 스레드를 사용하므로 스레드 수에 한계가 존재한다.
    - 스레드 1개당 1MB 사이즈라고 해도 4GB 메모리 환경에서 스레드 풀 크기는 4000개로 제한
    - 생성할 수 있는 스레드 수의 한계가 있어 스레드간 컨테스트 스위칭이 빈번해짐
- 서버의 요청 처리량을 증가시키면서 컨텍스트 스위칭 비용을 절감해야 하는 문제 해결이 필요하다.

따라서, 기존의 CPU를 최적으로 사용하지 못했던 근본적인 원인은?

- 자바 스레드와 커널 스레드가 일대일 대응되기 때문이다.
- 따라서, 커널 스레드와 일대일 대응되지 않는 구조의 스레드가 필요하다.
    - 경량 스레드 모델인 가상 스레드(virtual thread)의 탄생

**`가상 스레드(Virtual Thread)란?`**

- 가상 스레드에선 기존 자바 스레드 모델과 달리 ‘플랫폼 스레드’와 ‘가상 스레드’로 나뉨
- 가상 스레드는 플랫폼 스레드(기존 자바 스레드)와 N:1 관계이며 커널 스레드와는 연결되지 않는다.
    - 따라서 자바의 java.lang.Thread는 플랫폼 스레드에와 자바 런타임에만 의존할 수 있다.
- 이 플랫폼 스레드 위에서 가상 스레드가 번갈아 실행되는 구조이다.
    - 가상 스레드 하나가 블록되면 플랫폼 스레드는 연결된 다른 가상 스레드의 작업을 진행한다.
- 이런 식으로 **커널 스레드는 문맥 전환 없이 계속 애플리케이션 코드를 실행한다.**
    - 따라서 thread-per-request 스타일의 서버 애플리케이션이 하드웨어를 최적으로 사용할 수 있다.
    - 생성 비용이 저렴하고 단일 HTTP 요청 처리, 단일 JDBC 쿼리 정도만 수행하며 수명이 짧다.
- 이 새로운 모델은 현재의 스레드 관련 API를 최소한만 수정하도록 설계되었다.
    - 따라서 기존 코드도 큰 수정 없이 가상 스레드를 사용할 수 있게 되었다.
- 또한 라이브러리 차원에서 밑단의 구체적인 내용을 숨기므로 개발자는 어느 모델을 이용하는 중인지도 알 필요가 없다.
- MariaDB에서 JDBC 커넥터에 가상 스레드를 적용해서 테스트한 결과
    - 네 가지 시나리오에서 가상 스레드 사용이 기존보다 4.5~4.3배 빠른 성능을 보였다고 한다.
- **가상 스레드의 이점은 I/O 작업이 많아 스레드 전환이 자주 수행되는 상황에서 드러난다.**
- 해당 모델에서 가상 스레드를 이용하는 코드
    - 실행 대상 → 후속문(continuation), 즉, 실제 작업 내용
    - 스케줄러
        - 가상 스레드 모델은 OS의 스케줄러와 스케줄러 분리를 분리한다.
        - 기본 플랫폼 스레드의 스케줄러는 ForkJoinPool이다.
        - 이 스케줄러는 플랫폼 스레드 풀을 관리하며, 가상 스레드의 작업 스케줄링을 담당한다.

___

**가상 스레드의 동작 원리**

- 실행될 가상 스레드의 실제 작업 내용(continuation)을 carrier thread 의 workQueue에 push 한다.
    - 이때 carrier thread 는 작업 실행을 위임하는 플랫폼 스레드를 말한다.
    - carrier thread 에 가상 스레드의 continuation 단위로 스케줄링된다.
- queue 의 작업은 forkJoinPool에 의해 work stealing(FIFO)방식으로 플랫폼 스레드에 의해 수행된다.
- 처리되던 작업은 I/O나 인터럽트, 또는 작업 완료 시 workQueue에서 pop 되어 다시 힙 메모리로 돌아간다.
- 또 다시 해당 가상 스레드의 continuation 은 carrier thread(매번 다를 수 있음)에 스케줄링된다.

가상 스레드는 park, unpark 동작을 통해 컨텍스트 스위칭을 하는 형태로 동작한다. 

이는 실제 스레드의 비싼 컨텍스트 스위칭을 말하진 않는다.

- park:
    - 현재 스레드의 동작을 잠깐 멈추는 것, JVM 내부에서 상태 관리
    - 즉, OS level의 블로킹이 아님 → 논블로킹처럼 처리
- unpark:
    - 가상 스레드를 carrier thread 대기열에 넣는다.
    - 해당 continuation 지점부터 다시 재개한다.

___

**가상 스레드 결론**

- 가상 스레드는 가볍고, 빠르고, non-blocking 인 경량 스레드이다.
- 가상 스레드 모델은 JVM 스케줄링과 continuation을 통해 가상 스레드의 장점을 이용한다.
- 특징: 플랫폼 스레드 위에서 전환이 이루어지므로 OS 레벨의 스위칭이 일어나지 않는다.
    - 즉, OS 레벨의 비싼 컨텍스트 스위칭으로 인한 성능 저하가 없다.
    - 문맥 전환 없이 애플리케이션이 하드웨어를 더욱 최적으로 사용할 수 있다.
- 어떤 상황에 적용할까?
    - thread-per-request를 사용 중이며, I/O 블로킹이 주된 병목 문제일 때 고려 필요
- 빠르고 쉽게 적용 가능하다.
    - Reactive 프로그래밍이 러닝 커브로 부담되는 경우
    - kotlin coroutine 이 러닝 커브가 부담되는 경우