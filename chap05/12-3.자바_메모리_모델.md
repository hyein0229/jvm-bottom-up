# 12.3 자바 메모리 모델

- 서로 다른 운영체제의 물리 머신은 서로 다른 메모리 모델을 가진다고 했다.
    - ‘자바 가상 머신 명세’는 이로부터 자바 프로그램을 보호하고자 따로 자바 메모리 모델을 정의한다.
    - C/C++ 같은 언어는 하드웨어와 운영 체제의 메모리 모델을 직접 사용한다.
    - 따라서 한 플랫폼에서 정상 동작해도 다른 플랫폼에선 동작하지 않을 수 있다.
- 이 덕분에 자바 프로그램은 플랫폼에 상관없이 메모리를 일관된 방식으로 이용할 수 있다.
- 여러 스레드가 메모리에 동시 접근하여 메모리를 읽고 쓸 때의 일관성과 동기화를 보장한다.

## 12.3.1 메인 메모리와 작업 메모리

- 자바 메모리 모델의 주된 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정의하는 것이다.
- 즉, 가상 머신의 메모리에서 변수의 값을 저장하고 가져오는 것에 중점을 둔다.
    - 변수? → 인스턴스 필드, 정적 필드, 배열 객체의 원소와 같이 공유될 수 있는 것을 말함
- 자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다.
    - 이때의 메인 메모리는 물리 메모리가 아닌 가상 머신의 메모리이다.
- 그리고 각 스레드는 자체 작업 메모리를 갖는다.
    - 이는 물리 머신에서의 캐시 계층과 비슷한 역할을 한다.
    - 해당 스레드가 사용하는 메인 메모리의 변수의 복사본이 작업 메모리에 존재한다.
    - 스레드가 변수를 읽고 쓰는 모든 작업은 작업 메모리에서 수행되며, 메인 메모리의 데이터는 직접 읽고 쓸수가 없다.
    - 또한 스레드끼리는 서로의 작업 메모리에 있는 변수에 직접 접근할 수 없다.
    - 따라서 서로 값을 공유하기 위해선 무조건 메인 메모리를 거쳐야 한다.
- 메인 메모리와 작업 메모리 개념은 jvm 의 자바 힙, 스택, 메서드 영역과 아무 관련이 없다.
- 메인 메모리는 하드웨어 메모리에 대응하며, 작업 메모리는 레지스터나 캐시에 대응한다.
    - 가상 머신은 프로그램 성능을 위해 작업 메모리를 레지스터나 캐시에 미리 저장한다.
    - 작업 메모리에 잇는 데이터는 실행 중 주로 이용하는 부분이기 때문이다.

## 12.3.2 메모리 간 상호 작용

메인 메모리와 작업 메모리 사이의 프로토콜:

메인 메모리에서 작업 메모리로 변수를 복사하고, 다시 작업 메모리에서 메인으로 동기화하는 방법

**자바 메모리 모델은 프로토콜을 8가지로 정의**하며, 각각 원자적으로 이루어지도록 보장해야 한다.

- 잠금(lock):
    - 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다.
- 잠금 해제(unlock):
    - 잠겨 있는 변수를 잠금 해제한다.
    - 즉, 다른 스레드에 의해 잠길 수 있다.
- 읽기(read):
    - 뒤이어 수행되는 적재 연산을 위해 메인 메모리의 변숫값을 작업 메모리로 전송한다.
- 적재(load):
    - 읽기 연산으로 얻는 메인 메모리의 변숫값을 작업 메모리의 변수에 할당한다.
- 사용(use):
    - 작업 메모리의 변숫값을 실행 엔진으로 전달한다.
    - 가상 머신이 변숫값을 사용하는 바이트코드 명령어를 만날 때 실행된다.
- 할당(assign):
    - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당한다.
    - 가상 머신이 변수에 값을 할당하는 바이트코드 명령어를 만나면 실행된다.
- 저장(store):
    - 뒤이어 수행되는 쓰기 연산을 위해 작업 메모리의 변숫값을 메인 메모리로 전송한다.
- 쓰기(write):
    - 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록한다.

즉, 메인 → 작업으로 변수를 복사하기 위해선 읽기와 적재가 순차 진행되어야 한다. 

작업 → 메인으로 동기화를 위해선 저장과 쓰기가 순차 진행되어야 한다.

(하지만, 순서대로 수행되어야 할 뿐 바로 이어서 진행될 필요는 없다.)

**앞 8가지 기본 연산 수행 시 지켜야 하는 규칙**

1. 읽기와 적재, 저장과 쓰기는 단독으로 수행이 불가하다.
2. 작업 메모리에서 변숫값이 변경되면 메인 메모리로 동기화해야 한다.
3. 스레드는 작업 메모리의 데이터를 아무런 이유 없이(할당 없이) 메인 메모리로 동기화할 수 없다.
4. 변수는 메인 메모리에서만 새로 생길 수 있으며, 작업 메모리에 있는 초기화되지 않은(적재되거나 할당되지 않은) 변수를 곧바로 사용할 수 없다. 즉, 변수를 사용하거나 저장하기 전에 할당과 적재가 이루어져야 한다.
5. 변수는 한 번에 한 스레드만 잠글 수 있다. (같은 스레드라면 여러 번 잠글 수 있으나, 그만큼 해제해야 한다.)
6. 변수를 잠그면 작업 메모리의 변숫값을 지워진다 → 이전 스레드가 변경된 데이터로 메인에 다시 동기화했을 수 있으므로 스레드 간 데이터 일관성을 위함이다. 실행 엔진이 변수를 사용하기 위해선 적재 또는 할당을 다시 실행하여 초기화해야 한다.
7. 잠겨 있지 않은 변수나 다른 스레드가 잠근 변수는 잠금 해제할 수 없다.
8. 잠금을 해제하기 위해선 변수를 메인 메모리로 동기화해야 한다.

너무 복잡하다.

그래서 자바 설계진은 자바 메모리 모델 연산을 읽기, 쓰기, 잠금, 잠금 해제 4가지로 단순화한다.

(내부 설계가 달라진 것은 아니다.)

## 12.3.3 volatile 변수용 특별 규칙

- 자바 가상 머신이 제공하는 가장 가벼운 동기화 메커니즘이다.
- 하지만 이해하기 어려워 대부분 개발자는 volatile 대신 synchronized를 활용한다.
- volatile을 제대로 이해하면 멀티스레드 작업을 나눌 때 많은 도움이 된다.

**`volatile 변수가 가지는 2가지 특성`**

- 첫째, 모든 스레드에서 이 변수를 투명하게 볼 수 있다. 이를 “가시성을 보장한다”라고 말한다. 한 스레드가 값을 수정하면 다른 스레드도 새로운 값을 즉시 알게 된다는 뜻이다. 원래 일반 변수는 무조건 값이 메인 메모리를 거쳐 공유된다. 예를 들어 일반적으로는 스레드 A가 수정한 공유 변수의 값을 스레드 B가 확인하려면, 먼저 A가 수정된 값을 메인 메모리에 다시 기록해야 B가 다시 읽을 수 있다.
    
    volatile 변수는 항상 값을 메인 메모리에서 읽고, 메인 메모리에 즉각 쓴다.
    
    하지만, volatile 변수값은 모든 스레드에서 일관되므로 동시성 환경에서 안전할거라고 오해하면 안된다.
    
    자바의 산술 연산자는 원자적이 아니라서 volatile 이라도 멀티스레드 환경에서 완벽하게 안전하진 않다.
    
    ```java
    // volatile 로 동시성을 보장할 수 없는 잘못된 예시
    class Counter {
        public static volatile int count = 0;
    
        public static void increment() {
            count++;
        }
    }
    ```
    
    위 코드를 쓰레드 20개를 만들어 count 변수를 각 스레드가 1만번 증가시킨다고 하면 최종 결과는 20만이 출력되어야 할 것같지만 결과는 항상 달라지며 그보다 작은 숫자가 출력된다.
    
    이유는 증가 연산 count++는 실제로 바이트코드 명령어 4개로 구성되기 때문이다.
    
    - getstatic #7 → 정적 필드를 가져와 스택에 푸시
    - iconst_1 → 정수 1을 스택에 푸시
    - iadd → 스택의 두 정수값을 가져와 더함
    - putstatic → 스택의 맨 위값을 정적 필드에 다시 할당
    
    이때, getstatic 명렁어가 count 값을 피연산자 스택에서 가져올 때 volatile 키워드로 인해 count 값이 올바른지 확인한다. 하지만 iconst_1 과 iadd 등의 명령어 수행 동안 다른 스레드가 count 값을 변경해도 여전히 스택의 count 값은 변경 전 값이 된다. 따라서 이전 값에 기반한 계산 결과를 가져오게 된다.
    
    → **즉, 동시성 실패의 원인은 race condition 때문이다.**
    

따라서, 여기선 락을 활용하여 원자성을 보장하도록 해야 한다.

synchronized 키워드나 java.util.concurrent 패키지와 원자적 클래스의 락을 말한다.

동시성 제어에 volatile 사용이 매우 적합한 시나리오도 있다.

```java
volatile boolean shutdownRequested;

public void shutdown(){
    shutdownRequested = true;
}

public void doWork(){
    while(!shutdownRequested){
        // 비즈니스 로직
    }
}
```

이 코드는 shutdown() 메서드 호출 시 모든 스레드에서 실행 중인 doWork() 메서드가 즉시 종료한다.

- 둘째, 명령어 재정렬 최적화를 막아 준다. 일반 변수는 메서드 실행 중 최종 결과가 보장될 뿐 변수 할당 작업의 실행 순서가 프로그램 코드 순서와 같다는 보장은 없다. 이러한 명령어 재정렬은 같은 스레드에서 메서드를 실행하는 동안에는 탐지할 수 없다. 이를 자바 메모리 모델에선 ‘스레드안에서는 순차적인 시멘틱’ 이라 한다.
    
    명령어 재정렬 최적화는 프로그램의 동시 실행을 방해할 수 있다. 특정 코드가 조기 실행되면 같은 변수를 사용하는 다른 스레드에서 오류가 발생할 수 있다. 이를 volatile 이 막아준다.
    
    변수를 volatile 로 지정한 후에는 아래와 같이 메모리 장벽과 같은 작업이 추가되는데 이때, 바이트코드 명령어에 `lock 접두어`를 같이 사용한다. 
    
    ```java
    lock addl $0x0, (%esp) // 메모리 장벽 삽입
    ```
    
    메모리 장벽은 장벽 뒤 명령어를 장벽 앞으로 재정렬할 수 없도록 막는다.
    
    lock 접두어는 프로세서의 캐시를 메인 메모리에 쓰는 기능을 하며, 이 쓰기는 다른 프로세서가 자신의 캐시를 무효화하게 한다. 이 덕분에 volatile 변수의 수정 사항을 다른 스레드가 모두 볼 수 있는 것이다.
    

### `volatile 의 이점`

- 다른 동기화 도구보다 코드를 더 빠르게 실행한다.
    - 특정 상황에서 락 방식보다 성능이 좋다.
- volatile 변수의 읽기 성능은 일반 변수와 거의 같다.
    - 하지만 쓰기는 더 느릴 수 있다.
    - 명령어 재정렬을 막기 위해 메모리 장벽 명령어를 끼워 넣기 때문이다.
    - 그럼에도 전체 부하는 락보다 적다.
- 따라서, volatile 이 요구사항을 충족시키지 못하는 경우 외엔 락 대신 volatile을 사용하라
    - 상호 배제가 필요없는 간단한 동기화에만 가능하다.

## 12.3.4 long과 double 변수용 특별 규칙

- 좀 더 느슨한 특별 규칙이 적용된다.
- 가상 머신은 volatile이 아닌 64비트 데이터의 읽기/쓰기는 32비트 연산 2개로 나눠 처리할 수 있다.
- 즉, 64비트 데이터의 적재, 저장, 읽기, 쓰기 연산의 원자성 보장 여부를 선택할 수 있다.
- 이를 ‘long 과 double 변수의 비원자적 처리’라고 한다.
- 하지만, 현재 주류 플랫폼의 상용 64비트 가상머신은 비원자적 접근이 일어나지 않는다.
    - 즉, 여러 스레드가 공유하고 수정할 때 ‘반만 수정된’값을 읽을 수 있는 문제가 발생하지 않는다.
- 따라서 비원자적 처리로 인한 문제는 거의 일어나지 않는다고 보면 된다.
- 따라서 long 과 double 이라고 volatile 선언할 필요 없다.

## 12.3.5 원자성, 가시성, 실행 순서

자바 메모리 모델의 동시성 처리에서 원자성, 가시성, 실행 순서를 어떻게 처리하는지 살펴본다.

**원자성**

- 모델이 직접 보장하는 원자적 연산은 읽기, 적재, 할당, 사용, 저장, 쓰기다.
- 기본 데이터 타입으로의 모든 접근(읽기, 쓰기)는 대체로 원자적이라고 보면 된다.
- 애플리케이션 수준에서 원자성을 더 넓은 범위로 보장해야 할 때 **잠금, 잠금 해제 연산**을 제공한다.
- 이를 추상화된 바이트코드 명령어 monitorenter, monitorexit 로 제공한다.
    - 두 명령어는 자바 코드에서 **synchronized** 키워드로 동기화한 블록에 해당한다.
    - 동기화된 블록 전체는 원자적으로 수행됨이 보장된다.

**가시성**

- 공유 변수의 값을 한 스레드가 수정 시 수정 사항을 다른 스레드가 즉시 알 수 있음을 말한다.
- 변숫값 수정 시 즉시메인 메모리로 동기화하고, 읽을 때 메인 메모리로부터 갱신하는 식
    - 일반 변수나 volatile 변수나 동작은 같다.
    - 다만 volatile 은 특별 규칙에 의해 새로운 값을 즉시 동기화, 갱신한다는 점이다.
    - 따라서 멀티스레드 환경에서 volatile 만이 가시성을 보장한다.
- 이 외 자바에서의 가시성 확보용 키워드는 synchronized 와 final 이 있다.
    - synchronized: 변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화해야 한다(저장과 쓰기 수행)이라는 규칙으로 확보된다.
    - final: 객체가 생성될 때 생성자에서 한번만 초기화되므로 여러 스레드가 공유해도 같은 값이 보장된다.

**실행 순서**

- 현재 스레드에서 보면 모든 연산이 순서대로 실행되나, 다른 스레드에서 보면 순서가 다를 수 있다.
- 두 번째 문장은 ‘명령어 재정령’과 ‘작업 메모리와 메인 메모리 사이의 동기화 지연’ 현상을 의미한다.
- 자바 언어는 스레드 사이 작업 순서 보장을 위해 volatile 과 synchronized 를 제공한다.
    - volatile 은 명령어 재정렬을 금지한다.
    - synchronized는 락을 소유한 스레드만이 변수에 접근할 수 있도록 하여 순서를 보장한다.
    - 즉, synchronized 블록 두 개가 같은 락을 공유한다면 둘은 반드시 순서대로 진행된다.

세 가지의 특성이 모두 필요하다면? → synchronized 키워드를 사용하면 해결된다.

실제로 대부분의 동시성 제어는 synchronized 로 가능하다.

하지만 이를 남용하면 프로그램 성능을 크게 떨어트릴 수 있다.

## 12.3.6 선 발생 원칙

- 선 발생 원칙은 데이터 경합 여부와 스레드 안전성을 확인하는 데 유용한 수단이다.
- ‘선 발생’ 이란?
    - 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다.
    - 작업 A는 작업 B보다 선 발생한다라고 하면 A의 영향(수행 결과)을 B에서 관찰할 수 있다는 뜻이다.
    - ‘영향’은 공유 변수의 값 변경, 메시지 전송, 메서드 호출 등 모두를 포괄한다.
    
    ```java
    i = 1;  // 스레드 A에서 수행
    j = i;  // 스레드 B에서 수행
    i = 2;  // 스레드 C에서 수행
    ```
    
    선 발생 규칙에 의하면 B는 A의 수행을 관찰할 수 있고 C는 아직 등장하지 않으므로 j=1이다.
    
    C의 입장에서 B와 선후 관계가 없다면 C의 결과는 1가 될 수 있고 2도 될 수 있다.
    
    따라서, 멀티스레드 환경에서 잘못된 데이터를 읽을 수 있으므로 안전하지 못하다.
    

**선 발생 관계 목록**

두 작업 사이의 관계가 다음 목록에 없다면, 실행 순서가 보장되지 않는다.

- 프로그램 순서 규칙:
    - 한 스레드 내에선 ‘제어 흐름 순서’에 따라 앞의 연산이 뒤의 연산보다 선 발생한다.
    - 분기와 순환문 같은 구조까지 고려되므로 프로그램 코드 순서가 아닌 제어 흐름 순서가 기준이다.
- 모니터 락 규칙:
    - 잠금 해제 연산은 ‘같은 락’에 대한 잠금 연산보다 선 발생한다.
    - 이때 ‘같은 락’이 중요하며 같은 락이란 같은 객체 인스턴스를 말한다.
    - 여기서 순서는 ‘시간 순서’이다.
- 휘발성 변수 규칙:
    - volatile 변수의 쓰기 연산은 같은 변수에 대한 읽기 연산보다 선 발생한다.
    - 여기서 순서는 ‘시간 순서’이다.
- 스레드 시작 규칙:
    - Thread 객체의 start() 메서드는 해당 스레드의 어떤 작업보다 선 발생한다.
- 스레드 종료 규칙:
    - 스레드의 모든 작업은 해당 스레드의 종료 감지보다 선 발생한다.
    - 종료되었는지 여부는 Thread::join() 메서드나 , Thread::isAlive() 반환값으로 알 수 있다.
- 스레드 인터럽트 규칙:
    - Thread의 interrupt() 메서드 호출은 인터럽트되는 스레드가 인터럽트 이벤트 발생 감지보다 선 발생
    - 인터럽트 여부는 Thread::interrupted() 메서드로 감지할 수 있다.
- 종료자 규칙:
    - 객체 초기화는 finalize() 메서드 시작보다 선 발생한다.
- 전이성:
    - A가 B보다 먼저 발생하고, B가 C보다 먼저 발생한다고 하면 A는 C보다 선 발생한다고 할 수 있다.

자바는 어떠한 동기화 수단 지원 없이도 위의 선 발생 규칙을 보장한다.

선 발생과 시간 순서는 차이가 있다. 선 발생은 프로그램 상 순서, 시간 순서는 물리적 시간 순서이다.

```java
// 서로 다른 스레드 실행
// 모니터락, volatile 동기화 없음
// Thread 객체 메서드는 전혀 관련 없음
private int value = 0;

public void setValue(int value){
    this.value = value;
}

public int getValue(){
    return value;
}
```

서로 다른 스레드 A, B가 다음 순서로 실행한다.

1. A가 setValue(1) 실행
2. B가 getValue() 실행 → 결과는?

앞선 선 발생 관계 목록에서 위 코드의 선 발생을 보장해주는 규칙은 없다. 따라서 스레드 A가 B보다 먼저 수행되더라도 B가 얻는 결과를 보장할 수 없다. 즉, ‘시간 순서’로 먼저 발생해도 선 발생을 의미하진 않는다. 이는 멀티스레드 환경에서 안전하지 않다.

**위 작업을 안전하게 만들기 위해선?**

두 가지의 선택지가 존재한다.

- 게터/세터 메서드에 synchronized 를 사용하여 모니터 락 규칙을 적용한다.
- value 를 volatile 변수로 선언한다.

세터 메서드에서 value는 현재 값에 상관없이 값을 덮어씌운다. (++와 같이 현재값이 중요하지 않다.)

따라서, value를 volatile 로만 선언해도 충분하다. 이 경우 휘발성 변수의 선 발생 규칙을 적용할 수 있다.

그렇다면 ‘선 발생’은 ‘시간상 먼저 발생’해야 한다는 추론은 맞을까

```java
// 같은 스레드에서 수행
int i = 1;
int j = 2;
```

같은 스레드에서 위 코드를 수행한다면 프로그램 순서 규칙에 따라 i = 1 가 먼저 수행된다. 그러나, CPU에선 
int j = 2; 가 먼저 실행될 수 있다. 이는 ‘명령어 재정렬’ 때문이다. 하지만, 이 사실은 스레드 차원에선 인식할 수가 없다.

**핵심**

- 기본적으로 ‘시간 순서’와 ‘선 발생 원칙’에는 인과 관계가 없다.
- 따라서 **동시성 안전 문제를 분석할 땐 시간 순서에 얽매여선 안된다.**
- 모든 것은 선 발생 원칙에 기초해야 한다.
