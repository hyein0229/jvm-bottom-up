# 12.4 자바와 스레드

## 12.4.1 스레드 구현

스레드란?

- 스레드는 프로세서보다 가벼운 스케줄링 단위이다.
- 스레드 각각은 프로세스 자원을 공유할 수 있으며 독립적으로 스케줄링된다.
- 전통적으로 JDK 20까지 자바에선 스레드가 프로세서 자원 스케줄링의 최소 단위이다.
    - JDK 21 부턴 가상 스레드가 도입되어 달라졌다.

일반 애플리케이션 관점에서 스레드 구현 방법 3가지

- 커널 스레드(1:1 구현)
- 사용자 스레드 구현(1:N 구현)
- 사용자 스레드와 경량 프로세스의 하이브리드 구현(M:N 구현)

**`커널 스레드 구현`**

- 커널 스레드를 이용하는 구현이다.
    - 커널 스레드는 OS에서 직접 지원하는 스레드로, 스레드의 작업을 각 프로세서에 매핑하는 역할을 한다.
    - 커널 스레드 각각은 커널의 복제본과 같아 OS는 여러 가지 일을 동시에 처리할 수 있다.
    - 멀티스레딩을 지원하는 커널을 멀티스레드 커널이라고 한다.
- 프로그램은 커널 스레드를 직접 사용하지 않고, 대신 커널 스레드의 고수준 인터페이스인 경량 프로세스를 이용한다. (ex 자바의 Thread)
    - 경량 프로세스란 우리가 일반적으로 부르는 스레드를 말한다.
    - 따라서 경량 프로세스는 커널 스레드가 먼저 지원되어야 존재할 수 있다.
- 경량 프로세스와 커널 스레드 사이의 1:1 관계를 일대일 스레딩 모델이라 한다.
- 경량 프로세스는 커널 스레드의 도움을 받아 독립된 단위로 스케줄링될 수 있다.
    - 커널 스레드가 OS에 의해 프로세서 자원을 할당받으면 경량 프로세스가 실행될 수 있다.
    - Thread.start() 되면 커널 스레드 생성을 요청하고 할당받아 이후 스케줄러에 의해 실행될 수 있다.
- 경량 프로세스의 한계
    - 첫째, 커널 스레드를 기반으로 구현되어 생성, 소멸, 동기화 등 다양한 스레드 연산이 시스템 호출로 이루어진다. 시스템 콜은 사용자 모드 ↔ 커널 모드 전환이 필요하므로 비용이 높다.
    - 둘째, 경량 프로세스 하나가 커널 스레드에 매핑되므로 일정량의 커널 자원을 소모한다. 예를 들어 커널 스레드의 스택 공간을 소모한다. 따라서 시스템이 지원할 수 있는 경량 프로세스 개수에 제한이 있다.

**`사용자 스레드 구현`**

- ‘넓은 의미’론 커널 스레드가 아닌 모든 스레드는 사용자 스레드로 볼 수 있으며, 경량 프로세스도 그렇다.
- 하지만 경량 프로세스는 항상 커널을 기반으로 시스템 호출에 의존한다.
    - 즉, 일반적인 의미의 사용자 스레드가 주는 이점이 없다.
- ‘좁은 의미’론 사용자 스레드는 사용자 공간에서 구현되는 스레드 라이브러리를 가리킨다.
    - 즉, 사용자 스레드의 생성, 소멸, 동기화, 스케줄링이 모두 커널의 도움 없이 사용자 공간에서 처리한다.
    - 제대로 구현 시엔 커널 모드로 전환할 필요가 전혀 없다.
    - 매우 빠르고 저렴하여 더 많은 스레드를 지원할 수 있다.
- 사용자 스레드는 OS에서 알 수 없다. 프로세스 단위로만 스케줄링하게 된다.
- 일부 고성능 데이터베이스는 멀티스레딩을 사용자 스레드로 구현한다.
- 프로세스와 사용자 스레드 사이의 1:N 관계를 일대다 스레딩 모델이라고 한다.
- 장점은 시스템 커널의 지원이 없이 스레드를 제어할 수 있다는 점이다.
- 단점
    - 시스템 커널의 지원을 받지 못한다는 것
    - 생성, 소멸, 동기화, 스케줄링 등 작업을 모두 프로그램 상에서 사용자가 처리해야 하는데, 이 방식은 커널 스레드가 없으므로 프로세스
    - 사용자 스레드로 구현된 프로그램은 일반적으로 복잡하다.
        - 이때 프로그램은 스레드 구현에 필요한 코드를 직접 작성하는 프로그램을 말한다.
        - 보통은 전용 스레드 라이브러리를 사용하므로 복잡성을 감춰 준다.
- 일반 애플리케이션에서 사용자 스레드는 잘 사용하지 않는다.
- 최근 뛰어난 동시성을 내세우는 고 언어와 얼랭와 같은 다수의 언어는 사용자 스레드를 사용한다.
    - 이 언어들 덕분에 사용자 스레드 활용 비율이 높아지고 있는 추세라고 한다.

**`하이브리드 구현`**

- 커널 스레드와 사용자 스레드를 함께 이용하는 방식
- 이는 말그대로 사용자 스레드와 경량 프로세스가 공존한다.
- 경량 프로세스의 역할
    - 사용자 스레드와 커널 스레드 사이의 가교 역할을 한다.
- 사용자 스레드와 경량 프로세스가 N:M 관계를 가져 다대다 스레딩 모델이라 한다.
- 커널 스레드가 존재하므로 커널이 지원하는 스케줄링과 프로세서 매핑 기능을 활용할 수 있다.

**`자바 스레드 구현`**

- 자바 가상 머신 명세는 자바 스레드 구현 방식을 규정하지 않아 가상 머신에 따라 다를 수 있다.
- JDK 1.2 이전 클래식 VM은 그린 스레드(green thread)라는 사용자 스레드로 구현했다.
- JDK 1.3 부턴 운영 체제의 기본 스레드 모델 기반(주로 일대일 스레딩 모델)을 많이 선택한다.
- 핫스팟의 경우
    - 자바 스레드 각각은 중간에 간접 참조 없이 OS의 기본 스레드에 직접 매핑된다.
    - 따라서 핫스팟은 스레드 스케줄링에 관여하지 않고 온전히 OS가 처리한다.
        - 스레드 우선순위를 설정하여 운영체제에 조언은 가능하다.
- 운영 체제가 어떤 스레딩 모델을 제공하는냐가 JVM의 스레드가 매핑되는 방식에 영향을 준다.
- 스레딩 모델은 스레드의 동시성 규모와 운영 비용에만 영향을 주며, 코드 작성과는 무관하다.

## 12.4.2 자바 스레드 스케줄링

스레드 스케줄링이란 프로세서 사용 권한을 스레드에 할당하는 것을 말한다.

주요 스케줄링 방법에는 협력적 스케줄링과 선점형 스케줄링이 있다.

**협력적 스케줄링(cooperative scheduling)**

- 스레드 실행 시간을 스레드가 스스로 제어한다.
- 즉, 해당 스레드가 일을 완수할 때까지 중간에 다른 스레드가 실행 권한을 가지지 않는다.
- 일을 마친 스레드는 다른 스레드로 전환될 수 있도록 시스템에 알려야 한다.
- 장점
    - 첫째, 구현하기 쉽다.
    - 둘째, 일반적으로 동기화 문제가 발생하지 않는다. 스레드들은 다른 스레드로 전환하기 전에 자신이 해야 하는 일을 알고 수행을 완료한 후 전환할 수 있다. 루아(Lua)언어의 코루틴이 대표적인 예다.
- 단점
    - 스레드 코드에 문제가 있다면 다른 스레드로 전환되도록 시스템에 요청하지 않을 수 있어 프로그램 자체가 멈출 수 있다. 과거 윈도우 3.x는 협력적 스케줄링으로 멀티태스킹을 구현하여 매우 불안정하였다. 프로세스 하나가 프로세서를 쥐고 놓지 않으면 시스템 전체가 먹통이 될 수 있다.

**선점형 스케줄링(preemptive scheduling)**

- 각 스레드의 실행 시간을 시스템이 할당한다.
- 따라서 스레드는 전환 시점을 스스로 결정하지 못한다.
- 예를 들어 자바엔 실행 시간을 포기하는 Thread::yield() 메서드는 있으나, 가져오는 수단은 없다.
- 장점
    - 시스템이 스레드 실행 시간을 제어하므로 프로세스 하나가 시스템 전체를 먹통으로 만들 일이 없다.

**자바 스레드의 스케줄링 방식**

- 자바는 선점형 스케줄링을 이용한다. 이는 OS의 선점형 스케줄링 방식을 그대로 따른다는 뜻이다.
- 자바 스레드 스케줄링은 시스템이 자동 수행하지만, 특정 스레드에 더 많거나 더 적은 실행 시간을 할당하도록 운영 체제에 ‘권고’할 순 있다.
- 이를 위해 자바 언어는 스레드 우선선위를 10단계로 정의할 수 있다.
- 하지만 자바 언어가 제공하는 스레드 우선순위에 의존해선 안된다.
    - 이 스레드 우선순위는 OS에서의 스레드 우선순위와는 일치하지 않는다.
        - 예를 들어 윈도우가 제공하는 우선순위는 7가지 뿐이므로 몇개는 하나의 우선순위에 매핑된다.
    - 또한 윈도우는 우선순위 부스팅을 제공하여 우선순위가 달라질 수 있다.
        - 우선순위 부스팅은 자주 실행되는 스레드의 우선순위를 올려 실행 시간을 더 주는 방법이다.
        - 빈번한 스레드 전환으로 인한 성능 손실을 줄여준다.
    - 따라서 스레드 우선순위만으로 판단해선 안된다.

## 12.4.3 상태 전이

자바 언어에서의 스레드 상태는 총 여섯 가지이다.

어느 시점이든 스레드는 이 중 한가지의 상태에 놓이며, 특정 메서드를 호출하여 다른 상태로 전이할 수 있다.

- 신규(new): 스레드 생성 후 아직 시작되기 전 상태
- 실행 중: 운영 체제 스레드 상태 중 실행 중(running)과 준비(ready)에 해당한다.
- 무기한 대기: 프로세서 실행 시간이 할당되지 않았고, 다른 스레드가 명시적으로 깨워 주기를 기다리는 중이다. 다음 메서드가 무기한 대기 상태로 만든다.
    - 타임아웃 매개변수를 설정하지 않은 Object::wait()
    - 타임아웃 매개변수를 설정하지 않은 Thread::join()
    - LockSupport::park()
- 시간 제한 대기: 프로세서 실행 시간이 할당되지 않았으나 일정 시간이 지나면 시스템에 의해 자동으로 깨어난다. 다음 메서드들이 스레드를 시간 제한 대기로 만든다.
    - Thread::sleep()
    - 타임아웃 매개변수를 설정한 Object::wait()
    - 타임아웃 매개변수를 설정한 Thread::join()
    - LockSupport::parkNanos()
    - LockSupport::parkUntil()
- 블록: 스레드가 블록된 상태. 배타적 락을 얻기를 기다린다는 점에서 ‘대기’와 차이가 있다. 배타적 락은 다른 스레드가 해당 락을 해제할 때 얻을 수 있다. 반면 ‘대기’는 일정 시간 동안 또는 다른 스레드가 깨워 주기를 기다리는 것이다. 프로그램이 동기화된 영역에 진입하기를 기다리는 동안 이 상태가 된다.
    
    synchronized() 사용 시 블록 상태가 나타난다.
    
- 종료: 스레드가 실행을 마쳤다.