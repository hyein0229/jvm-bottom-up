# 13.3 락 최적화

락 최적화의 목적
- 동시성 효율을 크게 개선하여 최종적으로 프로그램 실행 효율을 높이는 것이다.
- 데이터를 더 효율적으로 공유하고 스레드 사이 경합 문제를 해결하는 것이 목표이다. 

## 13.3.1 스핀 락과 적응형 스핀
- 스핀 락(spin lock)은 스레드를 멈추지 않고 계속 락이 해제되었는지를 루프를 돌면서 확인하는 기술이다. 
- 등장한 배경
    - 이유1. 기존 상호 배제 동기화가 악영향을 주는 주 원인은 블로킹때문이다. 블로킹으로 스레드를 일시 정지시키고 다시 재개하는 것이 os 모드 전환을 일으켜 비용이 컸다.
    - 이유2. 분석 결과 수많은 애플리케이션이 공유 데이터를 아주 잠깐만 잠궜다가 다시 해제한다는 사실이다. 따라서 그 찰나의 순간을 위해서 스레드를 블로킹하는 것이 큰 의미가 없다. 
    - 이유3. 오늘날은 대부분이 멀티코어 시스템이다. 즉, 여러 스레드로 병렬 수행이 가능하여 대기 상태로 빠지지 않고도 락이 해제되는 지를 옆 코어에서 지켜볼 수 있다.
    - 따라서, 스레드를 멈추지 않고 루프를 계속 돌게 하는 것이다.
- jdk 6부턴 기본적으로 활성화되었다.
- 하지만, 스핀 락이 완전히 블로킹 방식을 대체할 순 없다. 
    - 스레드 전환으로 인한 부하는 없지만 busy-waiting 방식으로 계속 프로세서를 소모한다.
    - 따라서, 장시간 락을 잠군 경우엔 계속 자원만 소비하여 낭비한다.
    - 락을 짧게 사용하는 경우에만 효과적이다.
- 스핀 락 대기 시간에 제한을 두고 그 이상이 되면 스레드를 블로킹시켜야 한다. 
    - 최대 스핀 횟수는 기본 10회이며 -XX:PreBlockSpin 매개 변수로 설정이 가능하다.
    - 이 설정은 모든 락에 다 적용된다. (락의 시간은 다 다르기 때문에 단점이다.)
- jdk 6부턴 스핀 락을 최적화한 **`적응형 스핀(adaptive spin)`** 등장
    - 말 그대로 스핀 시간이 딱 고정되지 않았다.
    - 대신 같은 락의 이전 스핀 시간과 락 소유자의 상태에 따라 결정되는 것이다.
    - 하나의 락 객체에서 이전에 스핀 락이 성공한 경우 
        - 다음 번에도 Jvm 은 성공할 것이라고 판단한다.
        - 따라서 기존 스핀 횟수 한계까지 락을 얻지 못해도 '조금 더' 시도한다. 가령 100회까지 높인다.
    - 하나의 락 객체에서 이전에 스핀 락이 실패한 경우
        - 다음 번에도 가능성이 낮을 것으로 판단하고 스핀 로직을 완전히 생략할 수도 있다.
    - 적응형 스핀 락의 등장으로 -XX:PreBlockSpin 매개 변수는 jdk 7부터 끊겼다.

## 13.3.2 락 제거
- 특정 코드 조각에서 런타임에 경합이 일어나지 않는다고 판단되면 JIT 컴파일러가 해당 락을 제거해버리는 최적화 기법이다.
- 락 제거를 하는 판단 근거: 탈출 분석
    - 코드 조각에서 힙 안의 모든 데이터가 탈출하지 않고 다른 스레드에서 접근하지 않는다고 판단하는 것이다.
    - 탈출 여부는 이 객체가 메서드 외부로 넘겨지거나, 반환되는가, 다른 스레드 간 공유될 수 있는가 등이다.

**다음은 락 제거 최적화가 일어나는 코드이다.**
```java
public String concatSring(String s1, String s2, String s3){
    return s1 + s2 + s3 
}
```
- String 은 불변 객체이므로 합치기를 할 때 매번 String 객체를 생성해야만 한다.
- 따라서 javac 컴파일러가 최적화를 한다. jdk 1.4 까진 StringBuffer, jdk 5부턴 StringBuilder 사용한다.
    - 참고로 StringBuilder 는 스레드 안전하지 않은 StringBuffer 와 같다.
```java
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```
- StringBuffer 의 append() 메서드 내부엔 synchronized 를 사용하여 sb 객체가 락 객체로 이용된다.
- 가상 머신은 sb 객체의 탈출 여부를 분석하여 concatString() 바깥으로 탈출하지 않음을 확인한다.
- sb 는 다른 스레드에도, 메서드 밖에서도 공유될 일이 전혀 없다.
- 따라서 JIT 실행의 경우엔 락 제거 최적화를 적용한다.

## 13.3.3 락 범위 확장
- 기본적으로는 동기화 블록의 범위를 가능한 한 작게 하는 것이 좋다.
    - 동기화 범위를 줄여야 경합이 생겨도 대기가 줄어들고 가장 병렬적으로 수행될 수 있다.
- 하지만, 연이은 작업이나 순환문 안에서 계속 락을 잠그고 해제한다면?
    - 스레드 경합이 없어도 똑같은 락 객체를 반복 잠그고 해제하여 성능만 떨어트릴 수 있다.
    - 앞 stringBuffer 의 append() 예제가 이와 같다.
- 가상 머신은 똑같은 락 객체를 잠그는 일련의 작업을 발견하면 락의 유효 범위를 전체로 확장한다.

## 13.3.4 경량 락
- jdk 6부터 추가된 동기화 메커니즘이다.
- 경량이란? 운영 체제의 뮤텍스를 사용해 구현한 기존 락보다 가볍다는 뜻이다.
- 목적
    - 기존 락의 대체 목적은 아니다.
    - 목적은 스레드 경합을 없애 뮤텍스를 사용하는 기존 락의 성능 저하를 줄이는 것이다.
    - **락 경합이 전혀 없는 상황에서 블로킹으로 인한 불필요한 모드 전환을 피할 수 있다.**
- 동작 원리
    - 경량 락은 객체 헤더를 사용하여 동작한다.
    - 락 시도: 동기화 블록에 진입시 락 객체가 잠겨있지 않으면 현재 스레드의 스택 프레임에 락 레코드를 생성한다. 락 레코드는 소유한 락 객체를 저장하는 공간이다. 가상 머신은 CAS 연산으로 락 객체의 마크 워드를 본인의 락 레코드를 가리키는 포인터로 바꾸도록 시도한다.  
    - 락 성공: 자신의 락 레코드를 가리키는 포인터로 변경에 성공하면 현재 스레드가 락을 얻었음을 의미한다.
    - 락 실패: 변경에 실패하면 락 객체를 놓고 경합이 이루어지고 있다는 것, 즉 스레드가 최소 둘 이상이라는 것이다. 둘 이상의 스레드가 경합하는 상황에선 기존 락(블로킹 방식)으로 승격한다. 이땐 기존 락(뮤텍스)을 가리키는 포인터가 마크 워드에 저장된다.
    - 락 해제: 마크 워드를 원래 객체 복원한다.
    - 즉, 경합이 없다면 뮤텍스 대신 CAS 만으로 끝나므로 동기화 성능을 개선할 수 있다.
    - 하지만, 경합이 있다면 CAS 연산 부하에 뮤텍스 부하까지 더 추가되는 것이다.
- 스핀 락의 최적화와는 뭐가 다르냐
    - 스핀 락은 스레드 경합이 있는 상태에서 블로킹으로 인한 os 모드 전환 없이 락을 빠르게 확인하고 가져오기 위함, busy-wating 
    - 경량 락은 스레드 경합이 없을 때 블로킹(뮤텍스) 피하고 CAS 시도 1회만으로 가볍게 락을 걸어 사용하기 위함

## 13.3.5 편향 락
- jdk 18부턴 아예 제거되었다는데....
- 경합이 없을 때 동기화 장치들을 제거하여 프로그램 실행 성능을 높이는 최적화 기법이다.
- '편향' 의 의미는 락을 마지막으로 썼던 스레드가 락을 '찜' 해둔다는 의미이다.
- 따라서 다음 번에 다른 스레드가 쓰지 않으면 직전에 사용한 스레드는 동기화 작업 없이 사용할 수 있도록 하는 최적화 기법이다.
- 동기화는 하고 있지만 실질적인 경합 상황이 일어나지 않는 프로그램의 성능을 향상시킬 수 있다. 
- 왜 없어졌나
    - 편향 락의 혜택을 보는 애플리케이션은 주로 jdk 초기 컬렉션을 이용하던 레거시 프로그램이다.
    - jdk 1.2 이후의 컬렉션 API나 최근 API 를 사용하면 불필요한 경합 자체가 크게 줄어든다. 
    - 또한 편향 락 자체가 복잡한 로직을 수행한다.

